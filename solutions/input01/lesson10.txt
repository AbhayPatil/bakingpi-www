LESSON 10 INPUT01

The focus of this lesson is to get an input device, the keyboard, working with our operating system.  Usually, this sort of problem is solved by installing a USB driver for our operating system.  The problem is, there aren't any USB drivers written at a low enough level for our operating system.  Due to this, Alex spent many weeks writing a USB driver specifically for our device.  Unfortunately, it is not compatible with the new hardware on the Raspberry Pi 2.  Writing the USB driver is out of scope for the course which is the reason Alex provided it himself.  At the moment, I will not be able to complete the two input lessons without the USB driver.  Time permitting at the end of the semester I will attempt to get the USB driver working; however, I am making it a stretch goal.  For now I will only submit reports for input 01 and 02.

If we had a working USB driver I would have to proceed with linking the external code with my code.  Operating systems are not meant to be written by one person, so linking is an essential activity to utilize other people's code. Linking is the process of making our program link to other people's functions so we don't have to write them ourselves.  The two types of linking are static and dynamic.  Static linking finds all the function addresses and writes them into the code before the program completes.  Dynamic linking happens when the program is run, with the linker linking to functions found in a provided library file.

Interacting with the keyboard is pretty straightforward.  First we  check if a keyboard is connected and load the keyboard address.  Next we loop through each key to see if it's held down, and store the keys that are pressed.  Then we call the function KeyboardPoll which is provided by Alex's library to read the current state of the keyboard.  This is an example of polling I/O in which we constantly check for updates as opposed to interrupt driven I/O where the device signals when data is available.  Matching characters to key strokes is done through the use of a lookup table.  The lookup table contains several bytes, each containing a character.  From this, the method to return the proper character just returns the character byte at an offset to the lookup table struct.  For modifier keys, like shift, we can create another table and specify which lookup table to use. 
The final step is to create the notepad program.  The notepad program calls keyboard update to find the keyboard and then keyboard get char to get the pressed key.  It then draws the character and repeats.

As I stated earlier I wasn't able to get this code working.  I've only updated a few things in the lesson about the hardware, namely the number of USB ports on the raspberry Pi 2.  Time permitting I will come back to this and attempt to write a USB driver compatible with the new Pi.