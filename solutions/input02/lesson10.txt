LESSON10 INPUT02

The input 02 lesson takes our notepad OS from the last lesson and builds upon it to create a command line interface known as the terminal.  The terminal is the starting point for almost every OS.  The terminal allows a user to type a command to be executied by the computer.  The terminal displays both the input and the output of these commands.  The terminal in this lesson has two major data structures the terminal buffer and the terminal screen.  The buffer stores all the text that has been displayed while the screen stores the current characters.  This allows for a history of all the commands to be stored.  Additionally, this helps performance because previous commands don't have to be rewritten, which is an expensive operation.  We use a circular buffer to store this.  A circular buffer which keeps track of the beginning and end.  After the buffer size has been reached the end wraps around to the beginning.  This way the maximum size of the buffer is ensured without any expensive operations.

The main function required for the terminal is to display the text.  This function copies the data from the terminal buffer to the terminal screen and framebuffer.  In order to make this function efficient first the terminal display (which contains the current data) is compared with the terminal buffer to look for differences.  Then only the differences are drawn.  The next function required is to print lines.  The print function takes a string and a length and writes it to the current screen location.

Aside from output we need to also accept input. Unfortunately the little things in an input can make the method quite complex.  The standard input takes a user provided string under a maximum length and stores it into memory.  Additionally, the standard input needs a blinking cursor, live character printing to the display, the use of backspace to fix typos, and the return key to submit commands.  Much of this is done using the keyboard input created in the previous lesson and parsing the input looking for the special characters backspace and return.  

Finally, Alex provides some assembly instructions for the terminal application that allows users the echo, reset, ok, and cls commands.  Due to the issues with the USB driver I have to take this on faith that it works.  I hope to come back to this point to test the code on the Raspberry Pi 2.  This concludes my Raspberry Pi 2 operating systems course. Overall, I was able to get 80% of the lessons working on the Raspberry Pi 2, which is more than I originally expected.  I was also able to contribute to the bare metal forums for others working on these lessons.  Currently, I have my code and updated lessons hosted on my github, but if I can get these last two lessons complete I'll look to host the lessons on a website.